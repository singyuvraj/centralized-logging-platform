## TLS between Filebeat and Logstash (Phase 2)

This document centralizes all TLS-related details for the Filebeat → Logstash path. It is the single place to update whenever TLS behaviour changes.

### Scope

- **What is covered:** TLS encryption for Filebeat → Logstash on port 5044; HTTPS-only access to Elasticsearch (Logstash, es-setup, Kibana → Elasticsearch); nginx TLS for browser → Kibana.
- **What is not covered:** Mutual TLS (client certificates), certificate rotation policies, or production PKI.

---

### Directory layout and artefacts

- **Script:** `tls/gen-certs.sh`
  - Generates a local self-signed CA and a Logstash server certificate for development.
  - Idempotent enough for dev: re-creates `ca.crt`, `ca.key`, `logstash.crt`, `logstash.key` in `tls/`.
- **Generated files (gitignored):**
  - `tls/ca.crt`, `tls/ca.key`
  - `tls/logstash.crt`, `tls/logstash.key`
  - `tls/nginx.crt`, `tls/nginx.key` (public HTTPS for nginx)
  - `tls/kibana.crt`, `tls/kibana.key` (internal; used by nginx for Kibana→ES proxy when applicable)
  - `tls/elasticsearch.crt`, `tls/elasticsearch.key` (Elasticsearch HTTP layer HTTPS; SAN DNS:elasticsearch)
  - Temporary CSR/serial files are cleaned up by the script.

These artefacts are local-only for development. Production should use a real CA and properly managed certificates.

---

### Certificate generation (development)

Run once before `docker compose up`:

```bash
cd tls
chmod +x gen-certs.sh
./gen-certs.sh
```

What the script does:

- Generates a **CA key and certificate**:
  - `ca.key` (private) and `ca.crt` (public CA cert) with CN `Logstash Dev CA`.
- Generates a **Logstash server key and certificate**:
  - `logstash.key` (private) and `logstash.crt` (server cert) with:
    - CN `logstash`
    - SAN: `DNS:logstash`, `DNS:localhost`, `IP:127.0.0.1`
- Cleans up intermediate CSR/config and serial files.

The SAN includes `logstash` so that Filebeat connecting to `logstash:5044` can verify the hostname against the certificate.

---

### Docker Compose wiring

- **Logstash service:**
  - Mounts `./tls` at `/usr/share/logstash/certs:ro`.
  - Uses `logstash.crt` and `logstash.key` from that directory in the Beats input.
- **Filebeat service:**
  - Mounts `./tls` at `/usr/share/filebeat/certs:ro`.
  - Uses `ca.crt` from that directory to validate the Logstash server certificate.

Only the public CA cert (`ca.crt`) needs to be readable by Filebeat. Private keys never leave `tls/` inside the project directory and are not committed.

---

### Logstash configuration (Beats input)

`logstash/logstash.conf`:

```ruby
input {
  beats {
    port => 5044
    ssl_enabled => true
    ssl_certificate => "/usr/share/logstash/certs/logstash.crt"
    ssl_key => "/usr/share/logstash/certs/logstash.key"
  }
}
```

- Listens on port 5044.
- Presents `logstash.crt` as the server certificate and uses `logstash.key` as the private key.
- **No mutual TLS:** There is no client certificate requirement or verification for Beats clients.

Output remains stdout with `rubydebug` for verification; see Phase 2 implementation docs.

---

### Filebeat configuration (TLS output)

`filebeat/filebeat.yml`:

```yaml
output.logstash:
  hosts: ["logstash:5044"]
  ssl.enabled: true
  ssl.certificate_authorities: ["/usr/share/filebeat/certs/ca.crt"]
```

- Connects to `logstash:5044` using TLS.
- Validates the Logstash server cert against `ca.crt` generated by `gen-certs.sh`.
- **No client certs:** There is no `ssl.certificate` or `ssl.key` configured for Filebeat in this phase.

---

### Runtime expectations and verification

After running `tls/gen-certs.sh` and `docker compose up --build -d`:

- **Logstash logs** should show:
  - Beats input with TLS configuration (ssl_enabled and cert paths).
  - Listener on `0.0.0.0:5044`.
  - Events in stdout (rubydebug) with fields like `service.name`, `service.environment`, `env`, and `log.file.path` => `/apps/logs/application.log`.
- **Filebeat logs** should show:
  - Configured paths: `/apps/logs/*.log`.
  - Harvester for `/apps/logs/application.log`.
  - `Connection to backoff(async(tcp://logstash:5044)) established`.
  - Output type `logstash` with events acked.

See `docs/logging/testing.md` (Phase 2 + TLS section) for the exact commands and PASS/FAIL entries.

---

### Design choices and deferrals

- **Server-side TLS only:** We enable encrypted transport and server authentication. Mutual TLS (client authentication) is explicitly deferred.
- **Self-signed CA for development:** Simple, reproducible, and isolated. Production deployments should integrate with organization PKI or a managed CA.
- **Stdout output for Logstash:** Retained to keep TLS verification simple (no Elasticsearch yet). Future phases can add Elasticsearch output without changing the TLS handshake.

Any future change to TLS (paths, certificate source, mTLS, cipher suites, minimum protocol version, etc.) should be documented and explained in this file, with corresponding updates to Phase 2/3 docs as needed.

---

### Elasticsearch HTTP layer (HTTPS-only)

Elasticsearch is configured so that the REST API (port 9200) is served only over HTTPS. No component may use HTTP to talk to Elasticsearch.

- **Certificates:** Same CA as above. `tls/gen-certs.sh` generates `elasticsearch.key` and `elasticsearch.crt` (SAN DNS:elasticsearch) signed by the existing CA. No CA regeneration.
- **Elasticsearch:** `xpack.security.http.ssl.enabled=true`, `xpack.security.http.ssl.key` and `xpack.security.http.ssl.certificate` point to the mounted PEM files. Certs are mounted read-only at `/usr/share/elasticsearch/config/certs/`.
- **Logstash (Elasticsearch output):** `hosts => ["https://elasticsearch:9200"]`, `ssl => true`, `ssl_certificate_verification => true`, `cacert => "/usr/share/logstash/certs/ca.crt"`. Logstash mounts `./tls` at `/usr/share/logstash/certs`, so it uses the same CA to verify the Elasticsearch server cert.
- **es-setup:** Uses `ES_URL=https://elasticsearch:9200` and every curl uses `--cacert /scripts/ca.crt`. `./tls/ca.crt` is mounted at `/scripts/ca.crt:ro`.
- **Kibana:** `ELASTICSEARCH_HOSTS=https://elasticsearch:9200` with `ELASTICSEARCH_SSL_CERTIFICATEAUTHORITIES` pointing to the mounted CA. Kibana talks to Elasticsearch directly over HTTPS; no HTTP proxy in front of ES.

**Verification:** `curl http://elasticsearch:9200` must fail (no HTTP listener). `curl -k https://elasticsearch:9200/_cluster/health` (or with `--cacert`) and valid credentials must return cluster health. See `docs/logging/testing.md` (HTTPS-only section) for exact commands and PASS/FAIL.

